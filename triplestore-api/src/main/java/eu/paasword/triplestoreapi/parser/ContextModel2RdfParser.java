/*
 *  Copyright 2016 PaaSword Framework, http://www.paasword.eu/
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package eu.paasword.triplestoreapi.parser;

import java.io.FileReader;
import java.io.Reader;
import java.io.IOException;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import eu.paasword.triplestoreapi.client.TriplestoreClientFactory;

/**
 * Created by ipatini on 27/02/2017.
 */
public class ContextModel2RdfParser extends AbstractParser {

	private static final Logger logger = Logger.getLogger(ContextModel2RdfParser.class.getName());
	
	public static void main(String[] args) throws IOException {
		logger.log(Level.INFO, "** triplestore-api test **");
		String jsonFile = args[0].trim();
		
		try(Reader reader = new FileReader(jsonFile)){
			String jsonStr = new java.util.Scanner(new java.io.File(jsonFile)).useDelimiter("\\Z").next();
			ContextModel2RdfParser parser = new ContextModel2RdfParser();

			logger.log(Level.INFO, "** toTriplestore()");
			String rdfStr = parser.toTriplestore(jsonStr);
			System.out.println("RDF/TTL:\n"+rdfStr);
		}
	}
	
	public static String getRdfFromJson(String jsonStr) {
		Gson gson = new GsonBuilder().create();
		JsonDefinition jd = gson.fromJson(jsonStr, JsonDefinition.class);
		String rdfStr = toRdf(jd);
		return rdfStr;
	}
	
	public static String toTriplestore(String jsonStr) {
		String rdfStr = getRdfFromJson(jsonStr);
		return rdfStr;
	}
	
	//NOT IMPLEMENTED: It is not needed for the time being
	public static String fromTriplestore() {
		throw new RuntimeException("Method not implemented : fromTriplestore");
		/*String rdfStr = TriplestoreClientFactory.getClientInstance().exportFromTriplestore();
		//logger.log(Level.INFO, "Export from triplestore: \n{0}", rdfStr);
		
		//JsonDefinition jd = new JsonDefinition();
		JsonDefinition jd = toJsonDefinition( rdfStr );
		Gson gson = new GsonBuilder().create();
		String jsonStr = gson.toJson(jd);
		//logger.log(Level.INFO,jsonStr);
		return jsonStr;*/
	}
	
	private static String toRdf(JsonDefinition jdef) {
		StringBuilder sb = new StringBuilder();
		// produce header
		sb.append("# Generated by: ").append(ContextModel2RdfParser.class.getName()).append("\n");
		sb.append("# Date: ").append(new java.util.Date()).append("\n\n");
		
		// produce prefixes section
		// add base (if any)
		String baseUri = jdef.prefixes.get("");
		if (baseUri==null ||  baseUri.trim().isEmpty()) baseUri = jdef.prefixes.get(null);
		if (baseUri!=null && !baseUri.trim().isEmpty()) {
			sb.append("@base <").append(baseUri).append("> .").append("\n");
		}
		// add prefixes
		for (String prefix : jdef.prefixes.keySet()) {
			if (prefix==null || (prefix=prefix.trim()).isEmpty()) continue;
			String ns = jdef.prefixes.get(prefix);
			if (ns!=null) ns = ns.trim(); else ns = "";
			if (!ns.isEmpty()) {
				sb.append("@prefix ").append(prefix).append(": <").append(ns).append("> .").append("\n");
			}
		}
		
		// produce definitions section
		HashMap<Long,ClassDefinition> hmCdef = new HashMap<Long,ClassDefinition>();
		HashMap<Long,PropertyDefinition> hmProperty = new HashMap<Long,PropertyDefinition>();
		for (ClassDefinition cdef : jdef.definitions) {
			// get class id
			if (hmCdef.containsKey(cdef.id)) throw new RuntimeException(ContextModel2RdfParser.class.getName()+": ID already used for class definition: "+hmCdef.get(cdef.id).className);
			hmCdef.put(cdef.id, cdef);
			// get properties
			if (cdef.properties!=null) {
				for (PropertyDefinition pdef : cdef.properties) {
					hmProperty.put(pdef.id, pdef);
				}
			}
		}
		for (ClassDefinition cdef : jdef.definitions) {
			// class definition header
			sb.append("# =============================================================================").append("\n");
			sb.append("# Definition of class: ").append(cdef.className).append("\n");
			// sanitize class uri
			cdef.uri = sanitizeUri(cdef.uri);
			// class uri
			sb.append(cdef.uri).append("\ta\t").append("<http://www.w3.org/2000/01/rdf-schema#Class> ;").append("\n");
			// class id
			sb.append("\t").append("<http://purl.org/dc/terms/identifier>").append("\t\"").append(cdef.id).append("\"^^<http://www.w3.org/2001/XMLSchema#string> ; ").append("\n");
			// class parent
			if (cdef.hasFather) {
				ClassDefinition father = hmCdef.get(cdef.fatherID);
				if (father!=null) {
					sb.append("\t").append("<http://www.w3.org/2000/01/rdf-schema#subClassOf>").append("\t").append( sanitizeUri(father.uri) ).append(" ; ").append("\n");
				}
			}
			// class name
			sb.append("\t").append("<http://www.w3.org/2000/01/rdf-schema#label>").append("\t\"").append( sanitizeText(cdef.className) ).append("\"^^<http://www.w3.org/2001/XMLSchema#string> . ").append("\n\n");
			
			// class properties
			for (PropertyDefinition pdef : cdef.properties) {
				// sanitize property uri and type
				pdef.uri = sanitizeUri(pdef.uri);
				pdef.propertyType = sanitizeUri(pdef.propertyType);
				// property uri
				sb.append(pdef.uri).append("\n");
				// property type
				sb.append("\ta\t").append("<http://www.w3.org/1999/02/22-rdf-syntax-ns#Property>").append(" ; ").append("\n");
				// property transitivity
				if (pdef.transitivity>0) {
					sb.append("\ta\t").append("<http://www.w3.org/2002/07/owl#TransitiveProperty>").append(" ; ").append("\n");
				}
				// property parent property
				if (pdef.subPropertyOf!=null) {
					String parentUri = sanitizeUri(pdef.subPropertyOf.uri);
					sb.append("\t").append("<http://www.w3.org/2000/01/rdf-schema#subPropertyOf>").append("\t").append(parentUri).append(" ; ").append("\n");
				}
				// property id  (RDFS properties are NOT allowed to define properties other than the next...)
				sb.append("\t").append("<http://www.w3.org/2000/01/rdf-schema#comment>").append("\t\"ID=").append(pdef.id).append("\"^^<http://www.w3.org/2001/XMLSchema#string> ; ").append("\n");
				// property name
				sb.append("\t").append("<http://www.w3.org/2000/01/rdf-schema#label>").append("\t\"").append( sanitizeText(pdef.name) ).append("\"^^<http://www.w3.org/2001/XMLSchema#string> ; ").append("\n");
				// property domain
				sb.append("\t").append("<http://www.w3.org/2000/01/rdf-schema#domain>").append("\t").append(cdef.uri).append(" ; ").append("\n");
				// property range
				sb.append("\t").append("<http://www.w3.org/2000/01/rdf-schema#range>").append("\t").append(pdef.propertyType).append(" . ").append("\n\n");
			}
			
			// class instances
			for (InstanceDefinition idef : cdef.instances) {
				// sanitize instance uri
				idef.uri = sanitizeUri(idef.uri);
				
				// instance uri and type
				sb.append(idef.uri).append("\ta\t").append(cdef.uri).append(" ; ").append("\n");
				
				// class instance properties
				for (PropertyInstanceDefinition pidef : idef.propertyInstances) {
					String pUri = sanitizeUri( hmProperty.get(pidef.propertyID).uri );
					boolean isObj = hmProperty.get(pidef.propertyID).isObjectProperty;
					String pType = hmProperty.get(pidef.propertyID).propertyType;
					if (!isObj) sb.append("\t").append(pUri).append("\t\"").append( sanitizeText(pidef.value) ).append("\"^^").append(pType).append(" ; ").append("\n");
					else sb.append("\t").append(pUri).append("\t").append( sanitizeUri(pidef.value) ).append(" ; ").append("\n");
				}
				
				// instance id
				sb.append("\t").append("<http://purl.org/dc/terms/identifier>").append("\t\"").append(idef.id).append("\"^^<http://www.w3.org/2001/XMLSchema#string> ; ").append("\n");
				// instance name
				sb.append("\t").append("<http://www.w3.org/2000/01/rdf-schema#label>").append("\t\"").append( sanitizeText(idef.name) ).append("\"^^<http://www.w3.org/2001/XMLSchema#string> . ").append("\n\n");
			}
		}
		
		// produce handlers section
		sb.append("# =============================================================================").append("\n");
		sb.append("# Handler Definitions").append("\n");
		for (HandlerInstance handler : jdef.handlers) {
			String uri = handler.uri;
			if (uri==null) uri = handler.name;		// handler uri is contained in 'name' JSON field
			if (uri==null) continue;
			uri = sanitizeUri(uri);
			// handler uri
			sb.append(uri).append("\n");
			// handler instantiation
			sb.append("\ta\t").append("<http://www.paasword-project.eu/ontologies/casm/2016/05/20#ClassHandler> ;").append("\n");
			// handler id
			sb.append("\t").append("<http://purl.org/dc/terms/identifier>").append("\t\"").append(handler.id).append("\"^^<http://www.w3.org/2001/XMLSchema#string> ; ").append("\n");
			// handler name
			sb.append("\t").append("<http://www.w3.org/2000/01/rdf-schema#label>").append("\t\"").append( sanitizeText(handler.name) ).append("\"^^<http://www.w3.org/2001/XMLSchema#string> ; ").append("\n");
			// handler input type
			String ioUri = handler.hasInput;
			String p[] = ioUri.split(":",2);
			if (p.length==2) { String ns = jdef.prefixes.get(p[0]); if (ns!=null && !ns.trim().isEmpty()) ioUri = ns+p[1]; }
			sb.append("\t").append("<http://www.paasword-project.eu/ontologies/casm/2016/05/20#hasInput>").append("\t").append( sanitizeUri(ioUri) ).append(" ; ").append("\n");
			// handler output type
			ioUri = handler.hasOutput;
			p = ioUri.split(":",2);
			if (p.length==2) { String ns = jdef.prefixes.get(p[0]); if (ns!=null && !ns.trim().isEmpty()) ioUri = ns+p[1]; }
			sb.append("\t").append("<http://www.paasword-project.eu/ontologies/casm/2016/05/20#hasOutput>").append("\t").append( sanitizeUri(ioUri) ).append(" ; ").append("\n");
			// handler restEndpointURI
			sb.append("\t").append("<http://www.paasword-project.eu/ontologies/casm/2016/05/20#restEndpointURI>").append("\t<").append(handler.restEndpointURI).append("> . ").append("\n\n");
		}
		
		// produce footer
		sb.append("\n#EOF");
		return sb.toString();
	}
	
	//NOT IMPLEMENTED: It is not needed for the time being
	/*protected JsonDefinition toJsonDefinition(String rdfStr) {
		throw new RuntimeException("Method not implemented : toJsonDefinition");
	}*/
	
	
	protected static class JsonDefinition {

		java.util.HashMap<String,String> prefixes;
		java.util.Vector<HandlerInstance> handlers;
		java.util.Vector<ClassDefinition> definitions;
		
		public JsonDefinition() {
			prefixes = new java.util.HashMap<String,String>();
		}
		
		public String toString() {
			return toString(null).toString();
		}
		
		public StringBuilder toString(StringBuilder sb) {
			if (sb==null) sb = new StringBuilder();
			sb.append("@PREFIXES: ").append(prefixes).append("\n");
			sb.append("@HANDLERS: \n");
			for (HandlerInstance handler : handlers) handler.toString(sb).append("\n");
			sb.append("@CLASSES: \n");
			for (ClassDefinition cdef : definitions) cdef.toString(sb).append("\n");
			return sb;
		}
	}

	protected static class ClassDefinition {
		long id;
		String className;
		String uri;
		boolean hasFather;
		long fatherID;
		java.util.Vector<PropertyDefinition> properties;
		java.util.Vector<InstanceDefinition> instances;
		
		public ClassDefinition(long p1, String p2, String p3, boolean p4, long p5) {
			id = p1; className = p2; uri = p3; hasFather = p4; fatherID = p5;
			properties = new java.util.Vector<PropertyDefinition>();
			instances = new java.util.Vector<InstanceDefinition>();
		}
		public void addProperty(PropertyDefinition p) { properties.add(p); }
		public void addInstance(InstanceDefinition i) { instances.add(i); }
		
		public StringBuilder toString(StringBuilder sb) {
			sb.append( String.format("\tCLASS: id=%d, name=%s, has-father=%b, father=%d \n\turi = %s\n", id, className, hasFather, fatherID, uri) );
			sb.append("\tproperties = \n");
			for (PropertyDefinition pd : properties) pd.toString(sb);
			sb.append("\tinstances = \n");
			for (InstanceDefinition id : instances) id.toString(sb);
			return sb;
		}
	}
	protected static class HandlerInstance {
		long id;
		String name;
		String uri;
		String restEndpointURI;
		String hasInput;
		String hasOutput;
		public HandlerInstance(long p_id, String p_name, String p_uri, String p_endpoint, String p_input, String p_output) {
			id = p_id; name = p_name; uri = p_uri; restEndpointURI = p_endpoint; hasInput = p_input; hasOutput = p_output;
		}
		public String toString() {
			return toString(new StringBuilder()).toString();
		}
		public StringBuilder toString(StringBuilder sb) {
			sb.append( String.format("@HANDLER: id=%d, name=%s, uri=%s, endpoint=%s, input=%s, output=%s", id, name, uri, restEndpointURI, hasInput, hasOutput) );
			return sb;
		}
	}
	protected static class ParentPropertyDefinition {
		long id;
		String name;
		String uri;
		public ParentPropertyDefinition(long p1, String p2, String p3) {
			id = p1; name = p2; uri = p3;
		}
		public StringBuilder toString(StringBuilder sb) {
			sb.append( String.format("\t\t@PARENT-PROPERTY: id=%d, name=%s, uri=%s\n", id, name, uri) );
			return sb;
		}
	}
	protected static class PropertyDefinition {
		long id;
		String name;
		String uri;
		boolean isObjectProperty;
		String propertyType;
		int transitivity;
		ParentPropertyDefinition subPropertyOf;
		
		public PropertyDefinition(long p1, String p2, String p3, boolean p4, String p5, ParentPropertyDefinition p6) {
			id = p1; name = p2; uri = p3; isObjectProperty = p4; propertyType = p5; subPropertyOf = p6;
		}
		public StringBuilder toString(StringBuilder sb) {
			sb.append( String.format("\t\t@PROPERTY: id=%d, name=%s, is-object-prop=%b, type=%s, transitive=%d\n\t\t\turi=%s\n", id, name, isObjectProperty, propertyType, transitivity, uri) );
			if (subPropertyOf!=null) {
				sb.append("\t\t\t");
				subPropertyOf.toString(sb);
			}
			return sb;
		}
	}
	protected static class InstanceDefinition {
		long id;
		String name;
		String uri;
		java.util.Vector<PropertyInstanceDefinition> propertyInstances;
		
		public InstanceDefinition(long p1, String p2, String p3) {
			id = p1; name = p2; uri = p3;
			propertyInstances = new java.util.Vector<PropertyInstanceDefinition>();
		}
		public void addPropertyInstance(PropertyInstanceDefinition pi) { propertyInstances.add(pi); }
		public StringBuilder toString(StringBuilder sb) {
			sb.append( String.format("\t\t@INSTANCE: id=%d, name=%s, uri=%s\n\t\tproperty-instances:\n", id, name, uri) );
			for (PropertyInstanceDefinition pid : propertyInstances) pid.toString(sb);
			return sb;
		}
	}
	protected static class PropertyInstanceDefinition {
		long id;
		long propertyID;
		String value;
		
		public PropertyInstanceDefinition(long p1, long p2, String p3) {
			id = p1; propertyID = p2; value = p3;
		}
		public StringBuilder toString(StringBuilder sb) {
			sb.append( String.format("\t\t\t@PROPERTY-INSTANCE: id=%d, property-id=%d, value=%s\n", id, propertyID, value) );
			return sb;
		}
	}
}